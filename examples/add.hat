const myFn = fn a, b, c => a, b, c:
    return a, b, c
end

const g = 0

const as = closure fn => int
    // can use g freely
    return g
end

const main = fn:
    if cond:
        // branch one 
    else if cond:
        // branch 2
    end

    let i = 0;
    while cond:
        i = i + 1
    end

    let a = 0
    let p ^int
    a = @p
    p = &p

    // decl does not include the surrounding scope
    let b = decl :
        let a = 0
        return a
    end

    // When the keyword closure is used we allow variables from the surrounding scope.
    let s = closure decl :
        return a
    end
end
